/*
 * Fuel Quality Detection System
 * ESP32-WROOM-32 + TensorFlow Lite Micro
 * 
 * Sensors:
 * - Capacitive sensor (analog) for dielectric constant
 * - HC-SR04 Ultrasonic for sound velocity
 * - TDS sensor (analog) for conductivity
 * 
 * Output:
 * - 16x2 LCD showing result
 * - LEDs: Green (Pure), Red (Adulterated)
 */

#include <Wire.h>
#include <LiquidCrystal_I2C.h>

// Include the TensorFlow Lite model (will be generated by convert_to_tflite.py)
#include "model_data.h"

// TensorFlow Lite includes
#include <TensorFlowLite_ESP32.h>
#include "tensorflow/lite/micro/all_ops_resolver.h"
#include "tensorflow/lite/micro/micro_interpreter.h"
#include "tensorflow/lite/schema/schema_generated.h"

// ==================== PIN DEFINITIONS ====================
// Ultrasonic Sensor (HC-SR04)
#define ULTRASONIC_TRIG 5
#define ULTRASONIC_ECHO 18

// Analog Sensors
#define CAPACITIVE_PIN 35   // Capacitive sensor (ADC1_CH7)
#define TDS_PIN 34          // TDS sensor (ADC1_CH6)

// Output LEDs
#define LED_GREEN 25
#define LED_RED 27

// Push button to trigger reading
#define BUTTON_PIN 4

// LCD I2C Address (usually 0x27 or 0x3F)
#define LCD_ADDRESS 0x27

// ==================== CONSTANTS ====================
// ADC calibration values (adjust based on your sensors)
#define ADC_MAX 4095.0
#define V_REF 3.3

// Capacitive sensor calibration
// Map ADC reading to dielectric constant range (1.5 - 10.0)
#define DIELECTRIC_MIN 1.5
#define DIELECTRIC_MAX 10.0

// TDS sensor calibration
// Map ADC reading to conductivity range (0 - 100 μS/cm)
#define CONDUCTIVITY_MIN 0.0
#define CONDUCTIVITY_MAX 100.0

// Ultrasonic calibration
// Speed of sound reference and liquid path length
#define LIQUID_PATH_CM 5.0  // Distance through liquid in cm

// Detection threshold
#define DETECTION_THRESHOLD 0.5

// ==================== GLOBAL OBJECTS ====================
LiquidCrystal_I2C lcd(LCD_ADDRESS, 16, 2);

// TensorFlow Lite globals
const tflite::Model* model = nullptr;
tflite::MicroInterpreter* interpreter = nullptr;
TfLiteTensor* input = nullptr;
TfLiteTensor* output = nullptr;

// Tensor arena - memory for TFLite
constexpr int kTensorArenaSize = 8 * 1024;  // 8KB should be enough
uint8_t tensor_arena[kTensorArenaSize];

// ==================== SETUP ====================
void setup() {
    Serial.begin(115200);
    Serial.println("\n========================================");
    Serial.println("Fuel Quality Detection System");
    Serial.println("========================================\n");
    
    // Initialize pins
    pinMode(ULTRASONIC_TRIG, OUTPUT);
    pinMode(ULTRASONIC_ECHO, INPUT);
    pinMode(LED_GREEN, OUTPUT);
    pinMode(LED_RED, OUTPUT);
    pinMode(BUTTON_PIN, INPUT_PULLUP);
    
    // Initialize LCD
    Wire.begin(21, 22);  // SDA, SCL
    lcd.init();
    lcd.backlight();
    lcd.setCursor(0, 0);
    lcd.print("Fuel Detector");
    lcd.setCursor(0, 1);
    lcd.print("Initializing...");
    
    // Initialize TensorFlow Lite
    initTensorFlow();
    
    // Ready
    lcd.clear();
    lcd.setCursor(0, 0);
    lcd.print("Ready!");
    lcd.setCursor(0, 1);
    lcd.print("Press to test");
    
    Serial.println("System ready. Press button to analyze sample.");
}

void initTensorFlow() {
    Serial.println("Initializing TensorFlow Lite...");
    
    // Load the model
    model = tflite::GetModel(fuel_model_tflite);
    if (model->version() != TFLITE_SCHEMA_VERSION) {
        Serial.println("Model schema mismatch!");
        while (1);
    }
    
    // Create resolver and interpreter
    static tflite::AllOpsResolver resolver;
    static tflite::MicroInterpreter static_interpreter(
        model, resolver, tensor_arena, kTensorArenaSize);
    interpreter = &static_interpreter;
    
    // Allocate tensors
    if (interpreter->AllocateTensors() != kTfLiteOk) {
        Serial.println("AllocateTensors() failed!");
        while (1);
    }
    
    // Get input and output tensors
    input = interpreter->input(0);
    output = interpreter->output(0);
    
    Serial.println("TensorFlow Lite initialized successfully!");
    Serial.print("Input tensor size: ");
    Serial.println(input->bytes);
    Serial.print("Output tensor size: ");
    Serial.println(output->bytes);
}

// ==================== SENSOR READING FUNCTIONS ====================

float readDielectric() {
    // Read capacitive sensor ADC value
    int adcValue = analogRead(CAPACITIVE_PIN);
    
    // Map to dielectric constant range
    float dielectric = map(adcValue, 0, 4095, DIELECTRIC_MIN * 100, DIELECTRIC_MAX * 100) / 100.0;
    
    Serial.print("Dielectric ADC: ");
    Serial.print(adcValue);
    Serial.print(" -> Dielectric: ");
    Serial.println(dielectric);
    
    return dielectric;
}

float readUltrasonicVelocity() {
    // Send ultrasonic pulse
    digitalWrite(ULTRASONIC_TRIG, LOW);
    delayMicroseconds(2);
    digitalWrite(ULTRASONIC_TRIG, HIGH);
    delayMicroseconds(10);
    digitalWrite(ULTRASONIC_TRIG, LOW);
    
    // Read echo duration
    long duration = pulseIn(ULTRASONIC_ECHO, HIGH, 30000);  // 30ms timeout
    
    if (duration == 0) {
        Serial.println("Ultrasonic timeout!");
        return 1300.0;  // Return default value
    }
    
    // Calculate velocity
    // velocity = distance / time
    // For round trip through liquid: velocity = 2 * LIQUID_PATH_CM / (duration * 1e-6)
    float velocity = (2.0 * LIQUID_PATH_CM * 10000.0) / duration;  // m/s
    
    Serial.print("Ultrasonic duration: ");
    Serial.print(duration);
    Serial.print(" us -> Velocity: ");
    Serial.print(velocity);
    Serial.println(" m/s");
    
    return velocity;
}

float readConductivity() {
    // Read TDS sensor ADC value
    int adcValue = analogRead(TDS_PIN);
    
    // Map to conductivity range
    float conductivity = (adcValue / ADC_MAX) * CONDUCTIVITY_MAX;
    
    Serial.print("TDS ADC: ");
    Serial.print(adcValue);
    Serial.print(" -> Conductivity: ");
    Serial.print(conductivity);
    Serial.println(" μS/cm");
    
    return conductivity;
}

// ==================== NORMALIZATION ====================

void normalizeInputs(float dielectric, float velocity, float conductivity, float* normalized) {
    // Normalize using scaler parameters from training
    // These values are defined in model_data.h
    normalized[0] = (dielectric - SCALER_MEAN[0]) / SCALER_STD[0];
    normalized[1] = (velocity - SCALER_MEAN[1]) / SCALER_STD[1];
    normalized[2] = (conductivity - SCALER_MEAN[2]) / SCALER_STD[2];
    
    Serial.print("Normalized: [");
    Serial.print(normalized[0]);
    Serial.print(", ");
    Serial.print(normalized[1]);
    Serial.print(", ");
    Serial.print(normalized[2]);
    Serial.println("]");
}

// ==================== INFERENCE ====================

float runInference(float* normalizedInput) {
    // Copy input data to tensor
    for (int i = 0; i < 3; i++) {
        input->data.f[i] = normalizedInput[i];
    }
    
    // Run inference
    if (interpreter->Invoke() != kTfLiteOk) {
        Serial.println("Inference failed!");
        return -1;
    }
    
    // Get output
    float prediction = output->data.f[0];
    
    Serial.print("Model output: ");
    Serial.println(prediction);
    
    return prediction;
}

// ==================== DISPLAY RESULT ====================

void displayResult(float prediction, float dielectric, float velocity, float conductivity) {
    lcd.clear();
    
    if (prediction < 0) {
        lcd.setCursor(0, 0);
        lcd.print("ERROR!");
        lcd.setCursor(0, 1);
        lcd.print("Check sensors");
        digitalWrite(LED_GREEN, LOW);
        digitalWrite(LED_RED, HIGH);
        return;
    }
    
    if (prediction < DETECTION_THRESHOLD) {
        // Pure fuel
        lcd.setCursor(0, 0);
        lcd.print("PURE FUEL");
        lcd.setCursor(0, 1);
        lcd.print("Quality: GOOD");
        
        digitalWrite(LED_GREEN, HIGH);
        digitalWrite(LED_RED, LOW);
        
        Serial.println("\n*** RESULT: PURE FUEL ***");
    } else {
        // Adulterated fuel
        lcd.setCursor(0, 0);
        lcd.print("ADULTERATED!");
        lcd.setCursor(0, 1);
        lcd.print("Quality: BAD");
        
        digitalWrite(LED_GREEN, LOW);
        digitalWrite(LED_RED, HIGH);
        
        Serial.println("\n*** RESULT: ADULTERATED FUEL ***");
    }
    
    // Print detailed info to serial
    Serial.println("\n--- Sensor Readings ---");
    Serial.print("Dielectric: ");
    Serial.println(dielectric);
    Serial.print("Velocity: ");
    Serial.print(velocity);
    Serial.println(" m/s");
    Serial.print("Conductivity: ");
    Serial.print(conductivity);
    Serial.println(" μS/cm");
    Serial.print("Prediction score: ");
    Serial.println(prediction);
    Serial.println("-----------------------\n");
}

// ==================== MAIN LOOP ====================

void loop() {
    // Wait for button press
    if (digitalRead(BUTTON_PIN) == LOW) {
        // Debounce
        delay(50);
        if (digitalRead(BUTTON_PIN) == LOW) {
            // Wait for release
            while (digitalRead(BUTTON_PIN) == LOW) {
                delay(10);
            }
            
            // Start analysis
            lcd.clear();
            lcd.setCursor(0, 0);
            lcd.print("Analyzing...");
            Serial.println("\n=== Starting Analysis ===");
            
            // Read sensors (take average of 5 readings)
            float dielectric = 0, velocity = 0, conductivity = 0;
            const int NUM_READINGS = 5;
            
            for (int i = 0; i < NUM_READINGS; i++) {
                dielectric += readDielectric();
                velocity += readUltrasonicVelocity();
                conductivity += readConductivity();
                delay(100);
            }
            
            dielectric /= NUM_READINGS;
            velocity /= NUM_READINGS;
            conductivity /= NUM_READINGS;
            
            Serial.println("\n--- Averaged Readings ---");
            Serial.print("Dielectric: ");
            Serial.println(dielectric);
            Serial.print("Velocity: ");
            Serial.println(velocity);
            Serial.print("Conductivity: ");
            Serial.println(conductivity);
            
            // Normalize inputs
            float normalizedInput[3];
            normalizeInputs(dielectric, velocity, conductivity, normalizedInput);
            
            // Run inference
            float prediction = runInference(normalizedInput);
            
            // Display result
            displayResult(prediction, dielectric, velocity, conductivity);
        }
    }
    
    delay(10);
}

// ==================== SIMULATION MODE ====================
// Uncomment this function and call it from loop() to test without sensors

/*
void simulateAnalysis() {
    // Simulated sensor readings for testing
    float testCases[][3] = {
        {1.9, 1300, 0.3},   // Pure petrol
        {2.5, 1100, 5.0},   // Kerosene adulterated
        {7.0, 1400, 50.0},  // Water adulterated
        {2.2, 1200, 1.0}    // Diesel adulterated
    };
    
    static int testIndex = 0;
    
    float dielectric = testCases[testIndex][0];
    float velocity = testCases[testIndex][1];
    float conductivity = testCases[testIndex][2];
    
    Serial.println("\n=== Simulated Test Case ===");
    
    float normalizedInput[3];
    normalizeInputs(dielectric, velocity, conductivity, normalizedInput);
    
    float prediction = runInference(normalizedInput);
    displayResult(prediction, dielectric, velocity, conductivity);
    
    testIndex = (testIndex + 1) % 4;
}
*/
